{"ast":null,"code":"import { useContext as t, createContext as e, createElement as n, Fragment as o, PureComponent as s, createRef as r, useRef as i, useState as a, useEffect as p, memo as l, Children as c } from \"react\";\nimport u from \"invariant\";\nimport { Clusterer as d } from \"@react-google-maps/marker-clusterer\";\nimport { createPortal as h } from \"react-dom\";\nfunction g() {\n  return (g = Object.assign || function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var n = arguments[e];\n      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);\n    }\n    return t;\n  }).apply(this, arguments);\n}\nfunction f(t, e) {\n  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;\n}\nvar m = e(null);\nfunction v() {\n  t || u(!1);\n  var e = t(m);\n  return e || u(!1), e;\n}\nvar y = function y(t, e, n) {\n    return Object.keys(t).reduce(function (n, o) {\n      return e(n, t[o], o);\n    }, n);\n  },\n  M = function M(t, e, n, o) {\n    var s,\n      r,\n      i = {};\n    return s = t, r = function r(t, s) {\n      var r = n[s];\n      r !== e[s] && (i[s] = r, t(o, r));\n    }, Object.keys(s).forEach(function (t) {\n      return r(s[t], t);\n    }), i;\n  };\nfunction C(t) {\n  google.maps.event.removeListener(t);\n}\nfunction E(t) {\n  void 0 === t && (t = []), t.map(C);\n}\nfunction k(t) {\n  var e = t.eventMap,\n    n = t.nextProps,\n    o = t.instance;\n  return M(t.updaterMap, t.prevProps, n, o), function (t, e, n) {\n    return y(n, function (n, o, s) {\n      return \"function\" == typeof t[s] && n.push(google.maps.event.addListener(e, o, t[s])), n;\n    }, []);\n  }(n, o, e);\n}\nvar b = {\n    onDblClick: \"dblclick\",\n    onDragEnd: \"dragend\",\n    onDragStart: \"dragstart\",\n    onMapTypeIdChanged: \"maptypeid_changed\",\n    onMouseMove: \"mousemove\",\n    onMouseOut: \"mouseout\",\n    onMouseOver: \"mouseover\",\n    onMouseDown: \"mousedown\",\n    onMouseUp: \"mouseup\",\n    onRightClick: \"rightclick\",\n    onTilesLoaded: \"tilesloaded\",\n    onBoundsChanged: \"bounds_changed\",\n    onCenterChanged: \"center_changed\",\n    onClick: \"click\",\n    onDrag: \"drag\",\n    onHeadingChanged: \"heading_changed\",\n    onIdle: \"idle\",\n    onProjectionChanged: \"projection_changed\",\n    onResize: \"resize\",\n    onTiltChanged: \"tilt_changed\",\n    onZoomChanged: \"zoom_changed\"\n  },\n  w = {\n    extraMapTypes: function extraMapTypes(t, e) {\n      e.forEach(function (e, n) {\n        t.mapTypes.set(String(n), e);\n      });\n    },\n    center: function center(t, e) {\n      t.setCenter(e);\n    },\n    clickableIcons: function clickableIcons(t, e) {\n      t.setClickableIcons(e);\n    },\n    heading: function heading(t, e) {\n      t.setHeading(e);\n    },\n    mapTypeId: function mapTypeId(t, e) {\n      t.setMapTypeId(e);\n    },\n    options: function options(t, e) {\n      t.setOptions(e);\n    },\n    streetView: function streetView(t, e) {\n      t.setStreetView(e);\n    },\n    tilt: function tilt(t, e) {\n      t.setTilt(e);\n    },\n    zoom: function zoom(t, e) {\n      t.setZoom(e);\n    }\n  },\n  P = function (t) {\n    function e() {\n      var e;\n      return (e = t.apply(this, arguments) || this).state = {\n        map: null\n      }, e.registeredEvents = [], e.mapRef = null, e.getInstance = function () {\n        return new google.maps.Map(e.mapRef, e.props.options);\n      }, e.setMapCallback = function () {\n        null !== e.state.map && e.props.onLoad && e.props.onLoad(e.state.map);\n      }, e.getRef = function (t) {\n        e.mapRef = t;\n      }, e;\n    }\n    f(e, t);\n    var s = e.prototype;\n    return s.componentDidMount = function () {\n      var t = this.getInstance();\n      this.registeredEvents = k({\n        updaterMap: w,\n        eventMap: b,\n        prevProps: {},\n        nextProps: this.props,\n        instance: t\n      }), this.setState(function () {\n        return {\n          map: t\n        };\n      }, this.setMapCallback);\n    }, s.componentDidUpdate = function (t) {\n      null !== this.state.map && (E(this.registeredEvents), this.registeredEvents = k({\n        updaterMap: w,\n        eventMap: b,\n        prevProps: t,\n        nextProps: this.props,\n        instance: this.state.map\n      }));\n    }, s.componentWillUnmount = function () {\n      null !== this.state.map && (this.props.onUnmount && this.props.onUnmount(this.state.map), E(this.registeredEvents));\n    }, s.render = function () {\n      return n(\"div\", {\n        id: this.props.id,\n        ref: this.getRef,\n        style: this.props.mapContainerStyle,\n        className: this.props.mapContainerClassName\n      }, n(m.Provider, {\n        value: this.state.map\n      }, null !== this.state.map ? this.props.children : n(o, null)));\n    }, e;\n  }(s),\n  x = \"undefined\" != typeof document,\n  L = function L(t) {\n    var e = t.url,\n      n = t.id;\n    return x ? new Promise(function (t, o) {\n      if (document.getElementById(n)) return t(n);\n      var s = document.createElement(\"script\");\n      s.type = \"text/javascript\", s.src = e, s.id = n, s.async = !0, s.onload = function () {\n        t(n);\n      }, s.onerror = o, document.head.appendChild(s);\n    }).catch(function (t) {\n      console.error(\"injectScript error: \", t);\n    }) : Promise.reject(new Error(\"document is undefined\"));\n  },\n  D = function D(t) {\n    return !((!t.href || 0 !== t.href.indexOf(\"https://fonts.googleapis.com/css?family=Roboto\")) && (\"style\" === t.tagName.toLowerCase() && t.styleSheet && t.styleSheet.cssText && 0 === t.styleSheet.cssText.replace(\"\\r\\n\", \"\").indexOf(\".gm-style\") ? (t.styleSheet.cssText = \"\", 0) : \"style\" === t.tagName.toLowerCase() && t.innerHTML && 0 === t.innerHTML.replace(\"\\r\\n\", \"\").indexOf(\".gm-style\") ? (t.innerHTML = \"\", 0) : \"style\" !== t.tagName.toLowerCase() || t.styleSheet || t.innerHTML));\n  },\n  U = function U() {\n    console.log(\"preventGoogleFonts run\");\n    var t = document.getElementsByTagName(\"head\")[0],\n      e = t.insertBefore.bind(t);\n    t.insertBefore = function (n, o) {\n      D(n) || Reflect.apply(e, t, [n, o]);\n    };\n    var n = t.appendChild.bind(t);\n    t.appendChild = function (e) {\n      D(e) || Reflect.apply(n, t, [e]);\n    };\n  };\nfunction S(t) {\n  var e = t.googleMapsApiKey,\n    n = t.googleMapsClientId,\n    o = t.version,\n    s = void 0 === o ? \"weekly\" : o,\n    r = t.language,\n    i = t.region,\n    a = t.libraries,\n    p = [];\n  return e && n || !e || !n || u(!1), e ? p.push(\"key=\" + e) : n && p.push(\"client=\" + n), s && p.push(\"v=\" + s), r && p.push(\"language=\" + r), i && p.push(\"region=\" + i), a && a.length && p.push(\"libraries=\" + a.join(\",\")), \"https://maps.googleapis.com/maps/api/js?\" + p.join(\"&\");\n}\nvar O = !1;\nfunction T() {\n  return n(\"div\", null, \"Loading...\");\n}\nvar R,\n  V = {\n    id: \"script-loader\",\n    version: \"weekly\"\n  },\n  _ = function (t) {\n    function e() {\n      var e;\n      return (e = t.apply(this, arguments) || this).check = r(), e.state = {\n        loaded: !1\n      }, e.cleanupCallback = function () {\n        delete window.google, e.injectScript();\n      }, e.isCleaningUp = function () {\n        try {\n          return Promise.resolve(new Promise(function (t) {\n            if (O) {\n              if (x) var e = window.setInterval(function () {\n                O || (window.clearInterval(e), t());\n              }, 1);\n            } else t();\n          }));\n        } catch (t) {\n          return Promise.reject(t);\n        }\n      }, e.cleanup = function () {\n        O = !0;\n        var t = document.getElementById(e.props.id);\n        t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName(\"script\")).filter(function (t) {\n          return t.src.includes(\"maps.googleapis\");\n        }).forEach(function (t) {\n          t.parentNode && t.parentNode.removeChild(t);\n        }), Array.prototype.slice.call(document.getElementsByTagName(\"link\")).filter(function (t) {\n          return \"https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans\" === t.href;\n        }).forEach(function (t) {\n          t.parentNode && t.parentNode.removeChild(t);\n        }), Array.prototype.slice.call(document.getElementsByTagName(\"style\")).filter(function (t) {\n          return t.innerText.length > 0 && t.innerText.includes(\".gm-\");\n        }).forEach(function (t) {\n          t.parentNode && t.parentNode.removeChild(t);\n        });\n      }, e.injectScript = function () {\n        e.props.preventGoogleFontsLoading && U(), \"string\" != typeof e.props.id && u(!1);\n        var t = {\n          id: e.props.id,\n          url: S(e.props)\n        };\n        L(t).then(function () {\n          e.props.onLoad && e.props.onLoad(), e.setState(function () {\n            return {\n              loaded: !0\n            };\n          });\n        }).catch(function (t) {\n          e.props.onError && e.props.onError(t), console.error(\"\\n          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (\" + (e.props.googleMapsApiKey || \"-\") + \") or Client ID (\" + (e.props.googleMapsClientId || \"-\") + \") to <LoadScript />\\n          Otherwise it is a Network issue.\\n        \");\n        });\n      }, e;\n    }\n    f(e, t);\n    var s = e.prototype;\n    return s.componentDidMount = function () {\n      if (x) {\n        if (window.google && !O) return void console.error(\"google api is already presented\");\n        this.isCleaningUp().then(this.injectScript);\n      }\n    }, s.componentDidUpdate = function (t) {\n      this.props.libraries !== t.libraries && console.warn(\"Performance warning! Loadscript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable ounside of component, or somwhere in config files or ENV variables\"), x && t.language !== this.props.language && (this.cleanup(), this.setState(function () {\n        return {\n          loaded: !1\n        };\n      }, this.cleanupCallback));\n    }, s.componentWillUnmount = function () {\n      var t = this;\n      x && (this.cleanup(), setTimeout(function () {\n        t.check.current || (delete window.google, O = !1);\n      }, 1), this.props.onUnmount && this.props.onUnmount());\n    }, s.render = function () {\n      return n(o, null, n(\"div\", {\n        ref: this.check\n      }), this.state.loaded ? this.props.children : this.props.loadingElement || n(T, null));\n    }, e;\n  }(s);\nfunction I(t) {\n  var e = t.id,\n    n = void 0 === e ? V.id : e,\n    o = t.version,\n    s = void 0 === o ? V.version : o,\n    r = t.googleMapsApiKey,\n    l = t.googleMapsClientId,\n    c = t.language,\n    d = t.region,\n    h = t.libraries,\n    g = t.preventGoogleFontsLoading,\n    f = i(!1),\n    m = a(!1),\n    v = m[0],\n    y = m[1],\n    M = a(void 0),\n    C = M[0],\n    E = M[1];\n  p(function () {\n    return f.current = !0, function () {\n      f.current = !1;\n    };\n  }, []), p(function () {\n    x && g && U();\n  }, [g]), p(function () {\n    v && (window.google || u(!1));\n  }, [v]);\n  var k = S({\n    version: s,\n    googleMapsApiKey: r,\n    googleMapsClientId: l,\n    language: c,\n    region: d,\n    libraries: h\n  });\n  p(function () {\n    function t() {\n      f.current && (y(!0), R = k);\n    }\n    x && (window.google && R === k ? t() : L({\n      id: n,\n      url: k\n    }).then(t).catch(function (t) {\n      f.current && E(t), console.warn(\"\\n        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (\" + (r || \"-\") + \") or Client ID (\" + (l || \"-\") + \")\\n        Otherwise it is a Network issue.\\n      \"), console.error(t);\n    }));\n  }, [n, k]);\n  var b = i();\n  return p(function () {\n    b.current && h !== b.current && console.warn(\"Performance warning! Loadscript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables\"), b.current = h;\n  }, [h]), {\n    isLoaded: v,\n    loadError: C,\n    url: k\n  };\n}\n_.defaultProps = V;\nvar W = n(T, null);\nfunction A(t) {\n  var e = t.loadingElement,\n    n = t.onLoad,\n    o = t.onError,\n    s = t.onUnmount,\n    r = t.children,\n    i = I(function (t, e) {\n      if (null == t) return {};\n      var n,\n        o,\n        s = {},\n        r = Object.keys(t);\n      for (o = 0; o < r.length; o++) e.indexOf(n = r[o]) >= 0 || (s[n] = t[n]);\n      return s;\n    }(t, [\"loadingElement\", \"onLoad\", \"onError\", \"onUnmount\", \"children\"])),\n    a = i.isLoaded,\n    l = i.loadError;\n  return p(function () {\n    a && \"function\" == typeof n && n();\n  }, [a, n]), p(function () {\n    l && \"function\" == typeof o && o(l);\n  }, [l, o]), p(function () {\n    return function () {\n      s && s();\n    };\n  }, [s]), a ? r : e || W;\n}\nvar B = l(A),\n  N = {},\n  j = {\n    options: function options(t, e) {\n      t.setOptions(e);\n    }\n  },\n  z = function (t) {\n    function e() {\n      var e;\n      return (e = t.apply(this, arguments) || this).state = {\n        trafficLayer: null\n      }, e.setTrafficLayerCallback = function () {\n        null !== e.state.trafficLayer && e.props.onLoad && e.props.onLoad(e.state.trafficLayer);\n      }, e.registeredEvents = [], e;\n    }\n    f(e, t);\n    var n = e.prototype;\n    return n.componentDidMount = function () {\n      var t = new google.maps.TrafficLayer(g({}, this.props.options || {}, {\n        map: this.context\n      }));\n      this.registeredEvents = k({\n        updaterMap: j,\n        eventMap: N,\n        prevProps: {},\n        nextProps: this.props,\n        instance: t\n      }), this.setState(function () {\n        return {\n          trafficLayer: t\n        };\n      }, this.setTrafficLayerCallback);\n    }, n.componentDidUpdate = function (t) {\n      null !== this.state.trafficLayer && (E(this.registeredEvents), this.registeredEvents = k({\n        updaterMap: j,\n        eventMap: N,\n        prevProps: t,\n        nextProps: this.props,\n        instance: this.state.trafficLayer\n      }));\n    }, n.componentWillUnmount = function () {\n      null !== this.state.trafficLayer && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), E(this.registeredEvents), this.state.trafficLayer.setMap(null));\n    }, n.render = function () {\n      return null;\n    }, e;\n  }(s);\nz.contextType = m;\nvar G = function (t) {\n  function e() {\n    var e;\n    return (e = t.apply(this, arguments) || this).state = {\n      bicyclingLayer: null\n    }, e.setBicyclingLayerCallback = function () {\n      null !== e.state.bicyclingLayer && (e.state.bicyclingLayer.setMap(e.context), e.props.onLoad && e.props.onLoad(e.state.bicyclingLayer));\n    }, e;\n  }\n  f(e, t);\n  var n = e.prototype;\n  return n.componentDidMount = function () {\n    var t = new google.maps.BicyclingLayer();\n    this.setState(function () {\n      return {\n        bicyclingLayer: t\n      };\n    }, this.setBicyclingLayerCallback);\n  }, n.componentWillUnmount = function () {\n    null !== this.state.bicyclingLayer && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));\n  }, n.render = function () {\n    return null;\n  }, e;\n}(s);\nG.contextType = m;\nvar H = {\n    onCircleComplete: \"circlecomplete\",\n    onMarkerComplete: \"markercomplete\",\n    onOverlayComplete: \"overlaycomplete\",\n    onPolygonComplete: \"polygoncomplete\",\n    onPolylineComplete: \"polylinecomplete\",\n    onRectangleComplete: \"rectanglecomplete\"\n  },\n  Z = {\n    drawingMode: function drawingMode(t, e) {\n      t.setDrawingMode(e);\n    },\n    options: function options(t, e) {\n      t.setOptions(e);\n    }\n  },\n  F = function (t) {\n    function e(e) {\n      var n;\n      return (n = t.call(this, e) || this).registeredEvents = [], n.state = {\n        drawingManager: null\n      }, n.setDrawingManagerCallback = function () {\n        null !== n.state.drawingManager && n.props.onLoad && n.props.onLoad(n.state.drawingManager);\n      }, google.maps.drawing || u(!1), n;\n    }\n    f(e, t);\n    var s = e.prototype;\n    return s.componentDidMount = function () {\n      var t = new google.maps.drawing.DrawingManager(g({}, this.props.options || {}, {\n        map: this.context\n      }));\n      this.registeredEvents = k({\n        updaterMap: Z,\n        eventMap: H,\n        prevProps: {},\n        nextProps: this.props,\n        instance: t\n      }), this.setState(function () {\n        return {\n          drawingManager: t\n        };\n      }, this.setDrawingManagerCallback);\n    }, s.componentDidUpdate = function (t) {\n      null !== this.state.drawingManager && (E(this.registeredEvents), this.registeredEvents = k({\n        updaterMap: Z,\n        eventMap: H,\n        prevProps: t,\n        nextProps: this.props,\n        instance: this.state.drawingManager\n      }));\n    }, s.componentWillUnmount = function () {\n      null !== this.state.drawingManager && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), E(this.registeredEvents), this.state.drawingManager.setMap(null));\n    }, s.render = function () {\n      return n(o, null);\n    }, e;\n  }(s);\nF.contextType = m;\nvar K = {\n    onAnimationChanged: \"animation_changed\",\n    onClick: \"click\",\n    onClickableChanged: \"clickable_changed\",\n    onCursorChanged: \"cursor_changed\",\n    onDblClick: \"dblclick\",\n    onDrag: \"drag\",\n    onDragEnd: \"dragend\",\n    onDraggableChanged: \"draggable_changed\",\n    onDragStart: \"dragstart\",\n    onFlatChanged: \"flat_changed\",\n    onIconChanged: \"icon_changed\",\n    onMouseDown: \"mousedown\",\n    onMouseOut: \"mouseout\",\n    onMouseOver: \"mouseover\",\n    onMouseUp: \"mouseup\",\n    onPositionChanged: \"position_changed\",\n    onRightClick: \"rightclick\",\n    onShapeChanged: \"shape_changed\",\n    onTitleChanged: \"title_changed\",\n    onVisibleChanged: \"visible_changed\",\n    onZindexChanged: \"zindex_changed\"\n  },\n  Y = {\n    animation: function animation(t, e) {\n      t.setAnimation(e);\n    },\n    clickable: function clickable(t, e) {\n      t.setClickable(e);\n    },\n    cursor: function cursor(t, e) {\n      t.setCursor(e);\n    },\n    draggable: function draggable(t, e) {\n      t.setDraggable(e);\n    },\n    icon: function icon(t, e) {\n      t.setIcon(e);\n    },\n    label: function label(t, e) {\n      t.setLabel(e);\n    },\n    map: function map(t, e) {\n      t.setMap(e);\n    },\n    opacity: function opacity(t, e) {\n      t.setOpacity(e);\n    },\n    options: function options(t, e) {\n      t.setOptions(e);\n    },\n    position: function position(t, e) {\n      t.setPosition(e);\n    },\n    shape: function shape(t, e) {\n      t.setShape(e);\n    },\n    title: function title(t, e) {\n      t.setTitle(e);\n    },\n    visible: function visible(t, e) {\n      t.setVisible(e);\n    },\n    zIndex: function zIndex(t, e) {\n      t.setZIndex(e);\n    }\n  },\n  J = function (t) {\n    function e() {\n      var e;\n      return (e = t.apply(this, arguments) || this).registeredEvents = [], e.state = {\n        marker: null\n      }, e.setMarkerCallback = function () {\n        null !== e.state.marker && e.props.onLoad && e.props.onLoad(e.state.marker);\n      }, e;\n    }\n    f(e, t);\n    var n = e.prototype;\n    return n.componentDidMount = function () {\n      var t = g({}, this.props.options || {}, this.props.clusterer ? {} : {\n          map: this.context\n        }, {\n          position: this.props.position\n        }),\n        e = new google.maps.Marker(t);\n      this.props.clusterer ? this.props.clusterer.addMarker(e, !!this.props.noClustererRedraw) : e.setMap(this.context), this.registeredEvents = k({\n        updaterMap: Y,\n        eventMap: K,\n        prevProps: {},\n        nextProps: this.props,\n        instance: e\n      }), this.setState(function () {\n        return {\n          marker: e\n        };\n      }, this.setMarkerCallback);\n    }, n.componentDidUpdate = function (t) {\n      null !== this.state.marker && (E(this.registeredEvents), this.registeredEvents = k({\n        updaterMap: Y,\n        eventMap: K,\n        prevProps: t,\n        nextProps: this.props,\n        instance: this.state.marker\n      }));\n    }, n.componentWillUnmount = function () {\n      null !== this.state.marker && (this.props.onUnmount && this.props.onUnmount(this.state.marker), E(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.state.marker, !!this.props.noClustererRedraw) : this.state.marker && this.state.marker.setMap(null));\n    }, n.render = function () {\n      return this.props.children || null;\n    }, e;\n  }(s);\nJ.contextType = m;\nvar q = {\n    onClick: \"click\",\n    onClusteringBegin: \"clusteringbegin\",\n    onClusteringEnd: \"clusteringend\",\n    onMouseOut: \"mouseout\",\n    onMouseOver: \"mouseover\"\n  },\n  Q = {\n    averageCenter: function averageCenter(t, e) {\n      t.setAverageCenter(e);\n    },\n    batchSizeIE: function batchSizeIE(t, e) {\n      t.setBatchSizeIE(e);\n    },\n    calculator: function calculator(t, e) {\n      t.setCalculator(e);\n    },\n    clusterClass: function clusterClass(t, e) {\n      t.setClusterClass(e);\n    },\n    enableRetinaIcons: function enableRetinaIcons(t, e) {\n      t.setEnableRetinaIcons(e);\n    },\n    gridSize: function gridSize(t, e) {\n      t.setGridSize(e);\n    },\n    ignoreHidden: function ignoreHidden(t, e) {\n      t.setIgnoreHidden(e);\n    },\n    imageExtension: function imageExtension(t, e) {\n      t.setImageExtension(e);\n    },\n    imagePath: function imagePath(t, e) {\n      t.setImagePath(e);\n    },\n    imageSizes: function imageSizes(t, e) {\n      t.setImageSizes(e);\n    },\n    maxZoom: function maxZoom(t, e) {\n      t.setMaxZoom(e);\n    },\n    minimumClusterSize: function minimumClusterSize(t, e) {\n      t.setMinimumClusterSize(e);\n    },\n    styles: function styles(t, e) {\n      t.setStyles(e);\n    },\n    title: function title(t, e) {\n      t.setTitle(e);\n    },\n    zoomOnClick: function zoomOnClick(t, e) {\n      t.setZoomOnClick(e);\n    }\n  },\n  X = function (t) {\n    function e() {\n      var e;\n      return (e = t.apply(this, arguments) || this).registeredEvents = [], e.state = {\n        markerClusterer: null\n      }, e.setClustererCallback = function () {\n        null !== e.state.markerClusterer && e.props.onLoad && e.props.onLoad(e.state.markerClusterer);\n      }, e;\n    }\n    f(e, t);\n    var n = e.prototype;\n    return n.componentDidMount = function () {\n      if (this.context) {\n        var t = new d(this.context, [], this.props.options);\n        this.registeredEvents = k({\n          updaterMap: Q,\n          eventMap: q,\n          prevProps: {},\n          nextProps: this.props,\n          instance: t\n        }), this.setState(function () {\n          return {\n            markerClusterer: t\n          };\n        }, this.setClustererCallback);\n      }\n    }, n.componentDidUpdate = function (t) {\n      this.state.markerClusterer && (E(this.registeredEvents), this.registeredEvents = k({\n        updaterMap: Q,\n        eventMap: q,\n        prevProps: t,\n        nextProps: this.props,\n        instance: this.state.markerClusterer\n      }));\n    }, n.componentWillUnmount = function () {\n      null !== this.state.markerClusterer && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), E(this.registeredEvents), this.state.markerClusterer.setMap(null));\n    }, n.render = function () {\n      return null !== this.state.markerClusterer ? this.props.children(this.state.markerClusterer) : null;\n    }, e;\n  }(s);\nX.contextType = m;\nvar $ = {\n    onCloseClick: \"closeclick\",\n    onContentChanged: \"content_changed\",\n    onDomReady: \"domready\",\n    onPositionChanged: \"position_changed\",\n    onZindexChanged: \"zindex_changed\"\n  },\n  tt = {\n    options: function options(t, e) {\n      t.setOptions(e);\n    },\n    position: function position(t, e) {\n      t.setPosition(e);\n    },\n    zIndex: function zIndex(t, e) {\n      t.setZIndex(e);\n    }\n  },\n  et = function (t) {\n    function e() {\n      var e;\n      return (e = t.apply(this, arguments) || this).registeredEvents = [], e.containerElement = null, e.state = {\n        infoWindow: null\n      }, e.open = function (t, n) {\n        n ? t.open(e.context, n) : t.getPosition() ? t.open(e.context) : u(!1);\n      }, e.setInfowindowCallback = function () {\n        null !== e.state.infoWindow && null !== e.containerElement && (e.state.infoWindow.setContent(e.containerElement), e.open(e.state.infoWindow, e.props.anchor), e.props.onLoad && e.props.onLoad(e.state.infoWindow));\n      }, e;\n    }\n    f(e, t);\n    var s = e.prototype;\n    return s.componentDidMount = function () {\n      var t = new google.maps.InfoWindow(g({}, this.props.options || {}));\n      this.containerElement = document.createElement(\"div\"), this.registeredEvents = k({\n        updaterMap: tt,\n        eventMap: $,\n        prevProps: {},\n        nextProps: this.props,\n        instance: t\n      }), this.setState(function () {\n        return {\n          infoWindow: t\n        };\n      }, this.setInfowindowCallback);\n    }, s.componentDidUpdate = function (t) {\n      null !== this.state.infoWindow && (E(this.registeredEvents), this.registeredEvents = k({\n        updaterMap: tt,\n        eventMap: $,\n        prevProps: t,\n        nextProps: this.props,\n        instance: this.state.infoWindow\n      }));\n    }, s.componentWillUnmount = function () {\n      null !== this.state.infoWindow && (E(this.registeredEvents), this.state.infoWindow.close());\n    }, s.render = function () {\n      return this.containerElement ? h(c.only(this.props.children), this.containerElement) : n(o, null);\n    }, e;\n  }(s);\net.contextType = m;\nvar nt = {\n    onClick: \"click\",\n    onDblClick: \"dblclick\",\n    onDrag: \"drag\",\n    onDragEnd: \"dragend\",\n    onDragStart: \"dragstart\",\n    onMouseDown: \"mousedown\",\n    onMouseMove: \"mousemove\",\n    onMouseOut: \"mouseout\",\n    onMouseOver: \"mouseover\",\n    onMouseUp: \"mouseup\",\n    onRightClick: \"rightclick\"\n  },\n  ot = {\n    draggable: function draggable(t, e) {\n      t.setDraggable(e);\n    },\n    editable: function editable(t, e) {\n      t.setEditable(e);\n    },\n    map: function map(t, e) {\n      t.setMap(e);\n    },\n    options: function options(t, e) {\n      t.setOptions(e);\n    },\n    path: function path(t, e) {\n      t.setPath(e);\n    },\n    visible: function visible(t, e) {\n      t.setVisible(e);\n    }\n  },\n  st = function (t) {\n    function e() {\n      var e;\n      return (e = t.apply(this, arguments) || this).registeredEvents = [], e.state = {\n        polyline: null\n      }, e.setPolylineCallback = function () {\n        null !== e.state.polyline && e.props.onLoad && e.props.onLoad(e.state.polyline);\n      }, e;\n    }\n    f(e, t);\n    var s = e.prototype;\n    return s.componentDidMount = function () {\n      var t = new google.maps.Polyline(g({}, this.props.options || {}, {\n        map: this.context\n      }));\n      this.registeredEvents = k({\n        updaterMap: ot,\n        eventMap: nt,\n        prevProps: {},\n        nextProps: this.props,\n        instance: t\n      }), this.setState(function () {\n        return {\n          polyline: t\n        };\n      }, this.setPolylineCallback);\n    }, s.componentDidUpdate = function (t) {\n      null !== this.state.polyline && (E(this.registeredEvents), this.registeredEvents = k({\n        updaterMap: ot,\n        eventMap: nt,\n        prevProps: t,\n        nextProps: this.props,\n        instance: this.state.polyline\n      }));\n    }, s.componentWillUnmount = function () {\n      null !== this.state.polyline && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), E(this.registeredEvents), this.state.polyline.setMap(null));\n    }, s.render = function () {\n      return n(o, null);\n    }, e;\n  }(s);\nst.contextType = m;\nvar rt = {\n    onClick: \"click\",\n    onDblClick: \"dblclick\",\n    onDrag: \"drag\",\n    onDragEnd: \"dragend\",\n    onDragStart: \"dragstart\",\n    onMouseDown: \"mousedown\",\n    onMouseMove: \"mousemove\",\n    onMouseOut: \"mouseout\",\n    onMouseOver: \"mouseover\",\n    onMouseUp: \"mouseup\",\n    onRightClick: \"rightclick\"\n  },\n  it = {\n    draggable: function draggable(t, e) {\n      t.setDraggable(e);\n    },\n    editable: function editable(t, e) {\n      t.setEditable(e);\n    },\n    map: function map(t, e) {\n      t.setMap(e);\n    },\n    options: function options(t, e) {\n      t.setOptions(e);\n    },\n    path: function path(t, e) {\n      t.setPath(e);\n    },\n    paths: function paths(t, e) {\n      t.setPaths(e);\n    },\n    visible: function visible(t, e) {\n      t.setVisible(e);\n    }\n  },\n  at = function (t) {\n    function e() {\n      var e;\n      return (e = t.apply(this, arguments) || this).registeredEvents = [], e.state = {\n        polygon: null\n      }, e.setPolygonCallback = function () {\n        null !== e.state.polygon && e.props.onLoad && e.props.onLoad(e.state.polygon);\n      }, e.render = function () {\n        return null;\n      }, e;\n    }\n    f(e, t);\n    var n = e.prototype;\n    return n.componentDidMount = function () {\n      var t = new google.maps.Polygon(g({}, this.props.options || {}, {\n        map: this.context\n      }));\n      this.registeredEvents = k({\n        updaterMap: it,\n        eventMap: rt,\n        prevProps: {},\n        nextProps: this.props,\n        instance: t\n      }), this.setState(function () {\n        return {\n          polygon: t\n        };\n      }, this.setPolygonCallback);\n    }, n.componentDidUpdate = function (t) {\n      null !== this.state.polygon && (E(this.registeredEvents), this.registeredEvents = k({\n        updaterMap: it,\n        eventMap: rt,\n        prevProps: t,\n        nextProps: this.props,\n        instance: this.state.polygon\n      }));\n    }, n.componentWillUnmount = function () {\n      null !== this.state.polygon && (this.props.onUnmount && this.props.onUnmount(this.state.polygon), E(this.registeredEvents), this.state.polygon && this.state.polygon.setMap(null));\n    }, e;\n  }(s);\nat.contextType = m;\nvar pt = {\n    onBoundsChanged: \"bounds_changed\",\n    onClick: \"click\",\n    onDblClick: \"dblclick\",\n    onDrag: \"drag\",\n    onDragEnd: \"dragend\",\n    onDragStart: \"dragstart\",\n    onMouseDown: \"mousedown\",\n    onMouseMove: \"mousemove\",\n    onMouseOut: \"mouseout\",\n    onMouseOver: \"mouseover\",\n    onMouseUp: \"mouseup\",\n    onRightClick: \"rightclick\"\n  },\n  lt = {\n    bounds: function bounds(t, e) {\n      t.setBounds(e);\n    },\n    draggable: function draggable(t, e) {\n      t.setDraggable(e);\n    },\n    editable: function editable(t, e) {\n      t.setEditable(e);\n    },\n    map: function map(t, e) {\n      t.setMap(e);\n    },\n    options: function options(t, e) {\n      t.setOptions(e);\n    },\n    visible: function visible(t, e) {\n      t.setVisible(e);\n    }\n  },\n  ct = function (t) {\n    function e() {\n      var e;\n      return (e = t.apply(this, arguments) || this).registeredEvents = [], e.state = {\n        rectangle: null\n      }, e.setRectangleCallback = function () {\n        null !== e.state.rectangle && e.props.onLoad && e.props.onLoad(e.state.rectangle);\n      }, e;\n    }\n    f(e, t);\n    var s = e.prototype;\n    return s.componentDidMount = function () {\n      var t = new google.maps.Rectangle(g({}, this.props.options || {}, {\n        map: this.context\n      }));\n      this.registeredEvents = k({\n        updaterMap: lt,\n        eventMap: pt,\n        prevProps: {},\n        nextProps: this.props,\n        instance: t\n      }), this.setState(function () {\n        return {\n          rectangle: t\n        };\n      }, this.setRectangleCallback);\n    }, s.componentDidUpdate = function (t) {\n      null !== this.state.rectangle && (E(this.registeredEvents), this.registeredEvents = k({\n        updaterMap: lt,\n        eventMap: pt,\n        prevProps: t,\n        nextProps: this.props,\n        instance: this.state.rectangle\n      }));\n    }, s.componentWillUnmount = function () {\n      null !== this.state.rectangle && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), E(this.registeredEvents), this.state.rectangle.setMap(null));\n    }, s.render = function () {\n      return n(o, null);\n    }, e;\n  }(s);\nct.contextType = m;\nvar ut = {\n    onCenterChanged: \"center_changed\",\n    onClick: \"click\",\n    onDblClick: \"dblclick\",\n    onDrag: \"drag\",\n    onDragEnd: \"dragend\",\n    onDragStart: \"dragstart\",\n    onMouseDown: \"mousedown\",\n    onMouseMove: \"mousemove\",\n    onMouseOut: \"mouseout\",\n    onMouseOver: \"mouseover\",\n    onMouseUp: \"mouseup\",\n    onRadiusChanged: \"radius_changed\",\n    onRightClick: \"rightclick\"\n  },\n  dt = {\n    center: function center(t, e) {\n      t.setCenter(e);\n    },\n    draggable: function draggable(t, e) {\n      t.setDraggable(e);\n    },\n    editable: function editable(t, e) {\n      t.setEditable(e);\n    },\n    map: function map(t, e) {\n      t.setMap(e);\n    },\n    options: function options(t, e) {\n      t.setOptions(e);\n    },\n    radius: function radius(t, e) {\n      t.setRadius(e);\n    },\n    visible: function visible(t, e) {\n      t.setVisible(e);\n    }\n  },\n  ht = function (t) {\n    function e() {\n      var e;\n      return (e = t.apply(this, arguments) || this).registeredEvents = [], e.state = {\n        circle: null\n      }, e.setCircleCallback = function () {\n        null !== e.state.circle && e.props.onLoad && e.props.onLoad(e.state.circle);\n      }, e;\n    }\n    f(e, t);\n    var s = e.prototype;\n    return s.componentDidMount = function () {\n      var t = new google.maps.Circle(g({}, this.props.options || {}, {\n        map: this.context\n      }));\n      this.registeredEvents = k({\n        updaterMap: dt,\n        eventMap: ut,\n        prevProps: {},\n        nextProps: this.props,\n        instance: t\n      }), this.setState(function () {\n        return {\n          circle: t\n        };\n      }, this.setCircleCallback);\n    }, s.componentDidUpdate = function (t) {\n      null !== this.state.circle && (E(this.registeredEvents), this.registeredEvents = k({\n        updaterMap: dt,\n        eventMap: ut,\n        prevProps: t,\n        nextProps: this.props,\n        instance: this.state.circle\n      }));\n    }, s.componentWillUnmount = function () {\n      null !== this.state.circle && (this.props.onUnmount && this.props.onUnmount(this.state.circle), E(this.registeredEvents), this.state.circle && this.state.circle.setMap(null));\n    }, s.render = function () {\n      return n(o, null);\n    }, e;\n  }(s);\nht.contextType = m;\nvar gt = {\n    onAddFeature: \"addfeature\",\n    onClick: \"click\",\n    onDblClick: \"dblclick\",\n    onMouseDown: \"mousedown\",\n    onMouseOut: \"mouseout\",\n    onMouseOver: \"mouseover\",\n    onMouseUp: \"mouseup\",\n    onRemoveFeature: \"removefeature\",\n    onRemoveProperty: \"removeproperty\",\n    onRightClick: \"rightclick\",\n    onSetGeometry: \"setgeometry\",\n    onSetProperty: \"setproperty\"\n  },\n  ft = {\n    add: function add(t, e) {\n      t.add(e);\n    },\n    addgeojson: function addgeojson(t, e, n) {\n      t.addGeoJson(e, n);\n    },\n    contains: function contains(t, e) {\n      t.contains(e);\n    },\n    foreach: function foreach(t, e) {\n      t.forEach(e);\n    },\n    loadgeojson: function loadgeojson(t, e, n, o) {\n      t.loadGeoJson(e, n, o);\n    },\n    overridestyle: function overridestyle(t, e, n) {\n      t.overrideStyle(e, n);\n    },\n    remove: function remove(t, e) {\n      t.remove(e);\n    },\n    revertstyle: function revertstyle(t, e) {\n      t.revertStyle(e);\n    },\n    controlposition: function controlposition(t, e) {\n      t.setControlPosition(e);\n    },\n    controls: function controls(t, e) {\n      t.setControls(e);\n    },\n    drawingmode: function drawingmode(t, e) {\n      t.setDrawingMode(e);\n    },\n    map: function map(t, e) {\n      t.setMap(e);\n    },\n    style: function style(t, e) {\n      t.setStyle(e);\n    },\n    togeojson: function togeojson(t, e) {\n      t.toGeoJson(e);\n    }\n  },\n  mt = function (t) {\n    function e() {\n      var e;\n      return (e = t.apply(this, arguments) || this).registeredEvents = [], e.state = {\n        data: null\n      }, e.setDataCallback = function () {\n        null !== e.state.data && e.props.onLoad && e.props.onLoad(e.state.data);\n      }, e;\n    }\n    f(e, t);\n    var n = e.prototype;\n    return n.componentDidMount = function () {\n      var t = new google.maps.Data(g({}, this.props.options || {}, {\n        map: this.context\n      }));\n      this.registeredEvents = k({\n        updaterMap: ft,\n        eventMap: gt,\n        prevProps: {},\n        nextProps: this.props,\n        instance: t\n      }), this.setState(function () {\n        return {\n          data: t\n        };\n      }, this.setDataCallback);\n    }, n.componentDidUpdate = function (t) {\n      null !== this.state.data && (E(this.registeredEvents), this.registeredEvents = k({\n        updaterMap: ft,\n        eventMap: gt,\n        prevProps: t,\n        nextProps: this.props,\n        instance: this.state.data\n      }));\n    }, n.componentWillUnmount = function () {\n      null !== this.state.data && (this.props.onUnmount && this.props.onUnmount(this.state.data), E(this.registeredEvents), this.state.data && this.state.data.setMap(null));\n    }, n.render = function () {\n      return null;\n    }, e;\n  }(s);\nmt.contextType = m;\nvar vt = {\n    onClick: \"click\",\n    onDefaultViewportChanged: \"defaultviewport_changed\",\n    onStatusChanged: \"status_changed\"\n  },\n  yt = {\n    options: function options(t, e) {\n      t.setOptions(e);\n    },\n    url: function url(t, e) {\n      console.log({\n        instance: t,\n        url: e\n      }), t.setUrl(e);\n    },\n    zIndex: function zIndex(t, e) {\n      t.setZIndex(e);\n    }\n  },\n  Mt = function (t) {\n    function e() {\n      var e;\n      return (e = t.apply(this, arguments) || this).registeredEvents = [], e.state = {\n        kmlLayer: null\n      }, e.setKmlLayerCallback = function () {\n        null !== e.state.kmlLayer && e.props.onLoad && e.props.onLoad(e.state.kmlLayer);\n      }, e;\n    }\n    f(e, t);\n    var n = e.prototype;\n    return n.componentDidMount = function () {\n      var t = new google.maps.KmlLayer(g({}, this.props.options, {\n        map: this.context\n      }));\n      this.registeredEvents = k({\n        updaterMap: yt,\n        eventMap: vt,\n        prevProps: {},\n        nextProps: this.props,\n        instance: t\n      }), this.setState(function () {\n        return {\n          kmlLayer: t\n        };\n      }, this.setKmlLayerCallback);\n    }, n.componentDidUpdate = function (t) {\n      null !== this.state.kmlLayer && (E(this.registeredEvents), this.registeredEvents = k({\n        updaterMap: yt,\n        eventMap: vt,\n        prevProps: t,\n        nextProps: this.props,\n        instance: this.state.kmlLayer\n      }));\n    }, n.componentWillUnmount = function () {\n      null !== this.state.kmlLayer && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), E(this.registeredEvents), this.state.kmlLayer.setMap(null));\n    }, n.render = function () {\n      return null;\n    }, e;\n  }(s);\nMt.contextType = m;\nvar Ct = function Ct(t, e) {\n    return new e(t.lat, t.lng);\n  },\n  Et = function Et(t, e) {\n    return new e(new google.maps.LatLng(t.ne.lat, t.ne.lng), new google.maps.LatLng(t.sw.lat, t.sw.lng));\n  },\n  kt = function kt(t, e, n) {\n    return t instanceof e ? t : n(t, e);\n  },\n  bt = function bt(t, e, n, o) {\n    return void 0 !== n ? function (t, e, n) {\n      var o = t.fromLatLngToDivPixel(n.getNorthEast()),\n        s = t.fromLatLngToDivPixel(n.getSouthWest());\n      return o && s ? {\n        left: s.x + e.x + \"px\",\n        top: o.y + e.y + \"px\",\n        width: o.x - s.x - e.x + \"px\",\n        height: s.y - o.y - e.y + \"px\"\n      } : {\n        left: \"-9999px\",\n        top: \"-9999px\"\n      };\n    }(t, e, kt(n, google.maps.LatLngBounds, Et)) : function (t, e, n) {\n      var o = t.fromLatLngToDivPixel(n);\n      return o ? {\n        left: o.x + e.x + \"px\",\n        top: o.y + e.y + \"px\"\n      } : {\n        left: \"-9999px\",\n        top: \"-9999px\"\n      };\n    }(t, e, kt(o, google.maps.LatLng, Ct));\n  },\n  wt = function (t) {\n    function e() {\n      var e;\n      return (e = t.apply(this, arguments) || this).state = {\n        overlayView: null\n      }, e.containerElement = null, e.setOverlayViewCallback = function () {\n        null !== e.state.overlayView && e.props.onLoad && e.props.onLoad(e.state.overlayView);\n      }, e.onAdd = function () {\n        e.containerElement = document.createElement(\"div\"), e.containerElement.style.position = \"absolute\";\n      }, e.onPositionElement = function () {\n        if (null !== e.state.overlayView && null !== e.containerElement) {\n          var t = e.state.overlayView.getProjection(),\n            n = g({\n              x: 0,\n              y: 0\n            }, (s = e.containerElement, \"function\" == typeof (r = e.props.getPixelPositionOffset) ? r(s.offsetWidth, s.offsetHeight) : {})),\n            o = bt(t, n, e.props.bounds, e.props.position);\n          Object.assign(e.containerElement.style, o);\n        }\n        var s, r;\n      }, e.draw = function () {\n        e.props.mapPaneName || u(!1);\n        var t = e.state.overlayView;\n        if (null !== t) {\n          var n = t.getPanes();\n          n && (e.containerElement && n[e.props.mapPaneName].appendChild(e.containerElement), e.onPositionElement(), e.forceUpdate());\n        }\n      }, e.onRemove = function () {\n        null !== e.containerElement && e.containerElement.parentNode && (e.containerElement.parentNode.removeChild(e.containerElement), delete e.containerElement);\n      }, e;\n    }\n    f(e, t);\n    var s = e.prototype;\n    return s.componentDidMount = function () {\n      var t = new google.maps.OverlayView();\n      t.onAdd = this.onAdd, t.draw = this.draw, t.onRemove = this.onRemove, t.setMap(this.context), this.setState(function () {\n        return {\n          overlayView: t\n        };\n      }, this.setOverlayViewCallback);\n    }, s.componentDidUpdate = function (t) {\n      var e = this;\n      t.position === this.props.position && t.bounds === this.props.bounds || setTimeout(function () {\n        null !== e.state.overlayView && e.state.overlayView.draw();\n      }, 0);\n    }, s.componentWillUnmount = function () {\n      null !== this.state.overlayView && (this.props.onUnmount && this.props.onUnmount(this.state.overlayView), this.state.overlayView.setMap(null));\n    }, s.render = function () {\n      return null !== this.containerElement ? h(c.only(this.props.children), this.containerElement) : n(o, null);\n    }, e;\n  }(s);\nwt.FLOAT_PANE = \"floatPane\", wt.MAP_PANE = \"mapPane\", wt.MARKER_LAYER = \"markerLayer\", wt.OVERLAY_LAYER = \"overlayLayer\", wt.OVERLAY_MOUSE_TARGET = \"overlayMouseTarget\", wt.contextType = m;\nvar Pt = {\n    onDblClick: \"dblclick\",\n    onClick: \"click\"\n  },\n  xt = {\n    opacity: function opacity(t, e) {\n      t.setOpacity(e);\n    }\n  },\n  Lt = function (t) {\n    function e() {\n      var e;\n      return (e = t.apply(this, arguments) || this).registeredEvents = [], e.state = {\n        groundOverlay: null\n      }, e.setGroundOverlayCallback = function () {\n        null !== e.state.groundOverlay && e.props.onLoad && e.props.onLoad(e.state.groundOverlay);\n      }, e;\n    }\n    f(e, t);\n    var n = e.prototype;\n    return n.componentDidMount = function () {\n      console.log(\"this.props.url: \", this.props.url), console.log(\"this.props.bounds: \", this.props.bounds), this.props.url || this.props.bounds || u(!1);\n      var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, g({}, this.props.options, {\n        map: this.context\n      }));\n      this.registeredEvents = k({\n        updaterMap: xt,\n        eventMap: Pt,\n        prevProps: {},\n        nextProps: this.props,\n        instance: t\n      }), this.setState(function () {\n        return {\n          groundOverlay: t\n        };\n      }, this.setGroundOverlayCallback);\n    }, n.componentDidUpdate = function (t) {\n      null !== this.state.groundOverlay && (E(this.registeredEvents), this.registeredEvents = k({\n        updaterMap: xt,\n        eventMap: Pt,\n        prevProps: t,\n        nextProps: this.props,\n        instance: this.state.groundOverlay\n      }));\n    }, n.componentWillUnmount = function () {\n      this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));\n    }, n.render = function () {\n      return null;\n    }, e;\n  }(s);\nLt.defaultProps = {\n  onLoad: function onLoad() {}\n}, Lt.contextType = m;\nvar Dt = {},\n  Ut = {\n    data: function data(t, e) {\n      t.setData(e);\n    },\n    map: function map(t, e) {\n      t.setMap(e);\n    },\n    options: function options(t, e) {\n      t.setOptions(e);\n    }\n  },\n  St = function (t) {\n    function e() {\n      var e;\n      return (e = t.apply(this, arguments) || this).registeredEvents = [], e.state = {\n        heatmapLayer: null\n      }, e.setHeatmapLayerCallback = function () {\n        null !== e.state.heatmapLayer && e.props.onLoad && e.props.onLoad(e.state.heatmapLayer);\n      }, e;\n    }\n    f(e, t);\n    var n = e.prototype;\n    return n.componentDidMount = function () {\n      google.maps.visualization || u(!1), this.props.data || u(!1);\n      var t = new google.maps.visualization.HeatmapLayer(g({\n        data: this.props.data\n      }, this.props.options || {}, {\n        map: this.context\n      }));\n      this.registeredEvents = k({\n        updaterMap: Ut,\n        eventMap: Dt,\n        prevProps: {},\n        nextProps: this.props,\n        instance: t\n      }), this.setState(function () {\n        return {\n          heatmapLayer: t\n        };\n      }, this.setHeatmapLayerCallback);\n    }, n.componentDidUpdate = function (t) {\n      E(this.registeredEvents), this.registeredEvents = k({\n        updaterMap: Ut,\n        eventMap: Dt,\n        prevProps: t,\n        nextProps: this.props,\n        instance: this.state.heatmapLayer\n      });\n    }, n.componentWillUnmount = function () {\n      null !== this.state.heatmapLayer && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), E(this.registeredEvents), this.state.heatmapLayer.setMap(null));\n    }, n.render = function () {\n      return null;\n    }, e;\n  }(s);\nSt.contextType = m;\nvar Ot = {\n    onCloseClick: \"closeclick\",\n    onPanoChanged: \"pano_changed\",\n    onPositionChanged: \"position_changed\",\n    onPovChanged: \"pov_changed\",\n    onResize: \"resize\",\n    onStatusChanged: \"status_changed\",\n    onVisibleChanged: \"visible_changed\",\n    onZoomChanged: \"zoom_changed\"\n  },\n  Tt = {\n    register: function register(t, e, n) {\n      t.registerPanoProvider(e, n);\n    },\n    links: function links(t, e) {\n      t.setLinks(e);\n    },\n    motionTracking: function motionTracking(t, e) {\n      t.setMotionTracking(e);\n    },\n    options: function options(t, e) {\n      t.setOptions(e);\n    },\n    pano: function pano(t, e) {\n      t.setPano(e);\n    },\n    position: function position(t, e) {\n      t.setPosition(e);\n    },\n    pov: function pov(t, e) {\n      t.setPov(e);\n    },\n    visible: function visible(t, e) {\n      t.setVisible(e);\n    },\n    zoom: function zoom(t, e) {\n      t.setZoom(e);\n    }\n  },\n  Rt = function (t) {\n    function e() {\n      var e;\n      return (e = t.apply(this, arguments) || this).registeredEvents = [], e.state = {\n        streetViewPanorama: null\n      }, e.setStreetViewPanoramaCallback = function () {\n        null !== e.state.streetViewPanorama && e.props.onLoad && e.props.onLoad(e.state.streetViewPanorama);\n      }, e;\n    }\n    f(e, t);\n    var n = e.prototype;\n    return n.componentDidMount = function () {\n      var t = this.context.getStreetView();\n      this.registeredEvents = k({\n        updaterMap: Tt,\n        eventMap: Ot,\n        prevProps: {},\n        nextProps: this.props,\n        instance: t\n      }), this.setState(function () {\n        return {\n          streetViewPanorama: t\n        };\n      }, this.setStreetViewPanoramaCallback);\n    }, n.componentDidUpdate = function (t) {\n      null !== this.state.streetViewPanorama && (E(this.registeredEvents), this.registeredEvents = k({\n        updaterMap: Tt,\n        eventMap: Ot,\n        prevProps: t,\n        nextProps: this.props,\n        instance: this.state.streetViewPanorama\n      }));\n    }, n.componentWillUnmount = function () {\n      null !== this.state.streetViewPanorama && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), E(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));\n    }, n.render = function () {\n      return null;\n    }, e;\n  }(s);\nRt.contextType = m;\nvar Vt = function (t) {\n  function e() {\n    var e;\n    return (e = t.apply(this, arguments) || this).state = {\n      streetViewService: null\n    }, e.setStreetViewServiceCallback = function () {\n      null !== e.state.streetViewService && e.props.onLoad && e.props.onLoad(e.state.streetViewService);\n    }, e;\n  }\n  f(e, t);\n  var n = e.prototype;\n  return n.componentDidMount = function () {\n    var t = new google.maps.StreetViewService();\n    this.setState(function () {\n      return {\n        streetViewService: t\n      };\n    });\n  }, n.componentWillUnmount = function () {\n    null !== this.state.streetViewService && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);\n  }, n.render = function () {\n    return null;\n  }, e;\n}(s);\nVt.contextType = m;\nvar _t = function (t) {\n    function e() {\n      var e;\n      return (e = t.apply(this, arguments) || this).state = {\n        directionsService: null\n      }, e.setDirectionsServiceCallback = function () {\n        null !== e.state.directionsService && e.props.onLoad && e.props.onLoad(e.state.directionsService);\n      }, e;\n    }\n    f(e, t);\n    var s = e.prototype;\n    return s.componentDidMount = function () {\n      this.props.options || u(!1);\n      var t = new google.maps.DirectionsService();\n      this.setState(function () {\n        return {\n          directionsService: t\n        };\n      }, this.setDirectionsServiceCallback);\n    }, s.componentDidUpdate = function () {\n      null !== this.state.directionsService && this.state.directionsService.route(this.props.options, this.props.callback);\n    }, s.componentWillUnmount = function () {\n      null !== this.state.directionsService && this.props.onUnmount && this.props.onUnmount(this.state.directionsService);\n    }, s.render = function () {\n      return n(o, null);\n    }, e;\n  }(s),\n  It = {\n    onDirectionsChanged: \"directions_changed\"\n  },\n  Wt = {\n    directions: function directions(t, e) {\n      t.setDirections(e);\n    },\n    map: function map(t, e) {\n      t.setMap(e);\n    },\n    options: function options(t, e) {\n      t.setOptions(e);\n    },\n    panel: function panel(t, e) {\n      t.setPanel(e);\n    },\n    routeIndex: function routeIndex(t, e) {\n      t.setRouteIndex(e);\n    }\n  },\n  At = function (t) {\n    function e() {\n      var e;\n      return (e = t.apply(this, arguments) || this).registeredEvents = [], e.state = {\n        directionsRenderer: null\n      }, e.setDirectionsRendererCallback = function () {\n        null !== e.state.directionsRenderer && (e.state.directionsRenderer.setMap(e.context), e.props.onLoad && e.props.onLoad(e.state.directionsRenderer));\n      }, e;\n    }\n    f(e, t);\n    var s = e.prototype;\n    return s.componentDidMount = function () {\n      var t = new google.maps.DirectionsRenderer(this.props.options);\n      this.registeredEvents = k({\n        updaterMap: Wt,\n        eventMap: It,\n        prevProps: {},\n        nextProps: this.props,\n        instance: t\n      }), this.setState(function () {\n        return {\n          directionsRenderer: t\n        };\n      }, this.setDirectionsRendererCallback);\n    }, s.componentDidUpdate = function (t) {\n      null !== this.state.directionsRenderer && (E(this.registeredEvents), this.registeredEvents = k({\n        updaterMap: Wt,\n        eventMap: It,\n        prevProps: t,\n        nextProps: this.props,\n        instance: this.state.directionsRenderer\n      }));\n    }, s.componentWillUnmount = function () {\n      null !== this.state.directionsRenderer && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), E(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));\n    }, s.render = function () {\n      return n(o, null);\n    }, e;\n  }(s);\nAt.contextType = m;\nvar Bt = {\n    onPlacesChanged: \"places_changed\"\n  },\n  Nt = {\n    bounds: function bounds(t, e) {\n      t.setBounds(e);\n    }\n  },\n  jt = function (t) {\n    function e() {\n      var e;\n      return (e = t.apply(this, arguments) || this).registeredEvents = [], e.containerElement = r(), e.state = {\n        searchBox: null\n      }, e.setSearchBoxCallback = function () {\n        null !== e.state.searchBox && e.props.onLoad && e.props.onLoad(e.state.searchBox);\n      }, e;\n    }\n    f(e, t);\n    var o = e.prototype;\n    return o.componentDidMount = function () {\n      if (google.maps.places || u(!1), null !== this.containerElement && null !== this.containerElement.current) {\n        var t = this.containerElement.current.querySelector(\"input\");\n        if (t) {\n          var e = new google.maps.places.SearchBox(t, this.props.options);\n          this.registeredEvents = k({\n            updaterMap: Nt,\n            eventMap: Bt,\n            prevProps: {},\n            nextProps: this.props,\n            instance: e\n          }), this.setState(function () {\n            return {\n              searchBox: e\n            };\n          }, this.setSearchBoxCallback);\n        }\n      }\n    }, o.componentDidUpdate = function (t) {\n      null !== this.state.searchBox && (E(this.registeredEvents), this.registeredEvents = k({\n        updaterMap: Nt,\n        eventMap: Bt,\n        prevProps: t,\n        nextProps: this.props,\n        instance: this.state.searchBox\n      }));\n    }, o.componentWillUnmount = function () {\n      null !== this.state.searchBox && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), E(this.registeredEvents));\n    }, o.render = function () {\n      return n(\"div\", {\n        ref: this.containerElement\n      }, c.only(this.props.children));\n    }, e;\n  }(s);\njt.contextType = m;\nvar zt = {\n    onPlaceChanged: \"place_changed\"\n  },\n  Gt = {\n    bounds: function bounds(t, e) {\n      t.setBounds(e);\n    },\n    restrictions: function restrictions(t, e) {\n      t.setComponentRestrictions(e);\n    },\n    fields: function fields(t, e) {\n      t.setFields(e);\n    },\n    options: function options(t, e) {\n      t.setOptions(e);\n    },\n    types: function types(t, e) {\n      t.setTypes(e);\n    }\n  },\n  Ht = function (t) {\n    function e() {\n      var e;\n      return (e = t.apply(this, arguments) || this).registeredEvents = [], e.containerElement = r(), e.state = {\n        autocomplete: null\n      }, e.setAutocompleteCallback = function () {\n        null !== e.state.autocomplete && e.props.onLoad && e.props.onLoad(e.state.autocomplete);\n      }, e;\n    }\n    f(e, t);\n    var o = e.prototype;\n    return o.componentDidMount = function () {\n      google.maps.places || u(!1);\n      var t = this.containerElement.current.querySelector(\"input\");\n      if (t) {\n        var e = new google.maps.places.Autocomplete(t, this.props.options);\n        this.registeredEvents = k({\n          updaterMap: Gt,\n          eventMap: zt,\n          prevProps: {},\n          nextProps: this.props,\n          instance: e\n        }), this.setState(function () {\n          return {\n            autocomplete: e\n          };\n        }, this.setAutocompleteCallback);\n      }\n    }, o.componentDidUpdate = function (t) {\n      E(this.registeredEvents), this.registeredEvents = k({\n        updaterMap: Gt,\n        eventMap: zt,\n        prevProps: t,\n        nextProps: this.props,\n        instance: this.state.autocomplete\n      });\n    }, o.componentWillUnmount = function () {\n      null !== this.state.autocomplete && E(this.registeredEvents);\n    }, o.render = function () {\n      return n(\"div\", {\n        ref: this.containerElement\n      }, c.only(this.props.children));\n    }, e;\n  }(s);\nHt.contextType = m;\nexport { Ht as Autocomplete, G as BicyclingLayer, ht as Circle, mt as Data, At as DirectionsRenderer, _t as DirectionsService, F as DrawingManager, P as GoogleMap, Lt as GroundOverlay, St as HeatmapLayer, et as InfoWindow, Mt as KmlLayer, _ as LoadScript, B as LoadScriptNext, J as Marker, X as MarkerClusterer, wt as OverlayView, at as Polygon, st as Polyline, ct as Rectangle, jt as StandaloneSearchBox, Rt as StreetViewPanorama, Vt as StreetViewService, z as TrafficLayer, v as useGoogleMap, I as useLoadScript };","map":null,"metadata":{},"sourceType":"module"}